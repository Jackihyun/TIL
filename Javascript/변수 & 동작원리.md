## 변수

### 연산된 값이 메모리에 저장되는 과정
<br/>
CPU의 연산 -> 각 메모리 셀이 갖고 있는 메모리 주소에 저장
<br/>
하지만! 메모리 주소에 직접 접근 하면 안된다. 왜?
<br/>
1. 운영체제가 사용하고 있는 값을 변경하면 치명적 오류가 생긴다.<br/>
2. 코드가 실행될 때마다 메모리 주소가 바뀌어서 알 수가 없다.<br/>

<br/>

**그럼 어떻게 메모리 주소에 있는 값을 참조할 수 있을까?** 
<br/>

하나의 값을 저장하기 위한 메모리 공간 자체에 식별할 수 있는 이름을 부여해서 참조한다. -> **변수**

**변수는 값의 위치를 가리키는 상징적인 이름이다**

<br/>

### 자바 스크립트에서의 변수

**var 과 let, const**

var는 전역변수가 되서 부작용을 발생한다. <br/>
var의 단점을 보완하기 위해서 ES6에서 let 과 const가 추가 되었다.

var, let, const 와 같이 명령어를 js 엔진이 수행한다. -> **뒤에 오는 변수 이름으로 선언하는** 것을 수행

수행 이후 값을 할당하지 않아도 ```undefined```가 암묵적으로 할당된다.
<br/> -> 초기화라고 함.

#### undefined? <br/>
-> JS에서 제공하는 원시 타입의 값

#### 왜 초기화를 하나요?
-> 메모리 공간안에 이전의 다른 애플리케이션이 사용한 값이 저장되어 있을 수 있기 때문.

<br/>

### 변수 선언의 실행 시점과 변수 호이스팅
<br/>

```js
console.log(score); // undefined
var score;
```

위에서 부터 순차적으로 실행하는 인터프린터에 의해 ```undefined```가 안뜨고 
참조 에러가 발생할 줄 알았지만

소스코드가 순차적으로 실행되는 런타임 때 변수가 선언되는 것이 아니다!!!

그 이전에 소스코드 평가 과정때 선언이 된다.

JS엔진은 변수 선언을 포함한 모든 선언문을 먼저 실행한다.
-> 이러한 동작을 변수 호이스팅이라고 한다.

**그러면 선언문으로 먼저 실행되는 키워드는 뭐지?**

```var, let, const, function, function*, class``` 를 사용하는 모든 식별자가 호이스팅 된다.

<br/>

### 값의 할당

변수에 값을 할당할 때는 할당연산자(=)을 사용.

```js
  let score = 80;
```
```js
  let score;
  score = 80;
```

선언은 먼저 실행되지만 값의 할당은 '런타임' 시간때 실행된다.
-> 따라서 둘은 똑같다.

<br/>

### 값의 재할당

이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것을 재할당이라고 한다.

**어떠한 동작원리?**
-> 처음 변수에 할당하는 것처럼 기존의 공간에 넣는 것이 아니라 새로운 메모리 공간을 확보한뒤에 할당한다.

기존의 공간에 넣는 것은 -> 어떠한 식별자와도 연결 안되있는 쓰레기 값이 된다.

**쓰레기 값은 어디로 가나?**
-> 가비지 콜렉터를 통해 메모리가 자동으로 해제된다.

<br/>

### 식별자 네이밍 규칙

식별자는 어떠한 값을 정확히 식별할 수 있도록 네이밍을 구체적으로 해야한다.
네이밍은 규칙이 있다.

1. 특수문자를 제외한 숫자, 문자, _, $
2. 숫자로 시작하면 안된다.
3. 예약어와 같은 이름으로 하면 안된다.

```js
  var a = 90; // 좋지 않음
  var score = 90; // 좋음
```

네이밍은 하나이상의 영단어로 구성된 식별자를 만들 때 가독성을 좋게해야함.

```js
  var firstName; // camel
  var FirstName; // pascal
```
<br/>
1. 변수, 함수 -> 카멜 케이스 <br/>
2. 생성자 함수, 클래스 -> 파스칼 케이스

를 권장한다.




















